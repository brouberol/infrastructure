#!{{ user_home }}/notion/.env/bin/python

# {{ ansible_managed }}

import argparse
import calendar
import json
import logging
import os.path
from datetime import date

from notion.client import NotionClient

MAX_MONTHLY_HOURS = 50

logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)

tok = "{{ notion_token }}"

calendar_url = "{{ notion_cesu_calendar_url }}"

notion = NotionClient(token_v2=tok)
cal = notion.get_collection_view(calendar_url)


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--year", type=int)
    parser.add_argument("--month", type=int, choices=range(1, 13))
    parser.add_argument("--max-monthly-hours", type=int, default=MAX_MONTHLY_HOURS)
    parser.add_argument("-n", "--dry-run", action="store_true", default=False)
    return parser.parse_args()


def month_start_day(year, month):
    return date(year, month, 1)


def month_end_day(year, month):
    number_of_days_in_month = calendar.monthrange(year=year, month=month)[1]
    end_of_month = month_start_day(year, month).replace(day=number_of_days_in_month)
    return end_of_month


def get_month_total_hours(month_start, month_end):
    for row in filter_rows(title="CESU", start_date=month_start, end_date=month_end):
        return row.get_property("duration") or 0
    return 0


def filter_rows(title, start_date, end_date):
    rows = cal.collection.query(
        filter={
            "operator": "and",
            "filters": [
                {
                    "property": "c=qu",
                    "filter": {
                        "operator": "date_is_on_or_after",
                        "value": {
                            "type": "exact",
                            "value": {"type": "date", "start_date": str(start_date)},
                        },
                    },
                },
                {
                    "property": "c=qu",
                    "filter": {
                        "operator": "date_is_on_or_before",
                        "value": {
                            "type": "exact",
                            "value": {"type": "date", "start_date": str(end_date)},
                        },
                    },
                },
            ],
        }
    )
    return [row for row in rows if title in row.title]


def month_total_work_hours(month_start, month_end):
    # total_h = get_extra_hours(month_start, month_end)
    total_h = 0
    for row in filter_rows(title="Nicolas", start_date=month_start, end_date=month_end):
        work_h = row.get_property("duration")
        if not work_h:
            continue
        total_h += work_h
        logging.info(f"{work_h}h of work were reported on {row.date.start}")
    return total_h


def create_or_update_row(title, date, **properties):
    for row in cal.collection.get_rows(search=title):
        if row.date.start == date:
            # already exists
            for prop, val in properties.items():
                row.set_property(prop, val)
            return
    cal.collection.add_row(title=title, date=date, **properties)


def report_total_hours_on_month(month_end, total_h, dry_run):
    prefix = "[DRY RUN] " if dry_run else ""
    logging.info(f"{prefix}Reporting {total_h}h to the CESU row of {month_end}")
    if not dry_run:
        create_or_update_row("ðŸ”” CESU", month_end, duration=total_h)


def find_next_month(current_month, offset):
    if current_month + offset > 12:
        return current_month + offset - 12
    return current_month + offset


def get_max_monthly_hours_override(year, month):
    override_filepath = os.path.join(
        os.path.expanduser("~"), "notion", "overrides.json"
    )
    try:
        with open(override_filepath) as override_f:
            override_data = json.load(override_f)
    except FileNotFoundError:
        return None
    else:
        if override_data.get(str(year)) and override_data[str(year)].get(str(month)):
            return override_data[str(year)][str(month)]
        else:
            return None


def main():
    args = parse_args()
    month_start = month_start_day(args.year, args.month)
    month_end = month_end_day(args.year, args.month)
    total_h = month_total_work_hours(month_start, month_end)
    already_reported_work_h = get_month_total_hours(month_start, month_end)
    logging.info(
        f"Total work hours for {calendar.month_name[month_start.month]}: {total_h}, already reported {already_reported_work_h}h"
    )

    max_monthly_hours_override = get_max_monthly_hours_override(args.year, args.month)
    if max_monthly_hours_override:
        logging.info(
            f"Override set for {args.year}-{args.month} to {max_monthly_hours_override}h"
        )
        max_hours_for_current_month = max_monthly_hours_override
    else:
        max_hours_for_current_month = args.max_monthly_hours

    if total_h + already_reported_work_h > max_hours_for_current_month:
        if already_reported_work_h < args.max_monthly_hours:
            report_total_hours_on_month(
                month_end, max_hours_for_current_month, args.dry_run
            )
            total_h = total_h + already_reported_work_h - max_hours_for_current_month

        i = 1
        while total_h > 0:
            next_month = find_next_month(args.month, i)
            next_year = args.year if (args.month + i) <= 12 else args.year + 1
            next_month_end_day = month_end_day(next_year, next_month)
            already_reported_hours_for_next_month = get_month_total_hours(
                next_month_end_day, next_month_end_day
            )
            total_h += already_reported_hours_for_next_month
            if total_h > args.max_monthly_hours:
                total_h -= args.max_monthly_hours
                report_total_hours_on_month(
                    next_month_end_day, args.max_monthly_hours, args.dry_run
                )
            else:
                report_total_hours_on_month(next_month_end_day, total_h, args.dry_run)
                total_h = 0
            i += 1
    else:
        report_total_hours_on_month(
            month_end, total_h + already_reported_work_h, args.dry_run
        )


if __name__ == "__main__":
    main()
